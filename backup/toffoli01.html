<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Qubit Quantum Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 1.5rem;
            max-width: 1200px; /* Limits the width of the top panels */
            width: 100%;
            box-sizing: border-box;
        }
        @media (min-width: 1024px) {
            .container {
                flex-direction: row; /* For desktop, panels side-by-side */
                justify-content: space-around;
                align-items: flex-start; /* Align panels at the top */
            }
        }
        .panel {
            background-color: #2d3748; /* Darker panel background */
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        label {
            font-weight: 600;
            color: #cbd5e0;
        }
        input[type="number"] {
            background-color: #4a5568;
            border: 1px solid #6b7280;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            color: #e2e8f0;
            width: 100%;
            box-sizing: border-box;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5);
        }
        button {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .output-group {
            background-color: #1a202c;
            padding: 0.75rem;
            border-radius: 0.375rem;
            color: #a0aec0;
            font-family: 'Courier New', Courier, monospace;
            word-break: break-all;
            white-space: pre-wrap;
            min-height: 2.5rem;
            display: flex;
            align-items: center;
        }
        .output-complex {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        .output-complex > div {
            background-color: #1a202c;
            padding: 0.75rem;
            border-radius: 0.375rem;
            color: #a0aec0;
            font-family: 'Courier New', Courier, monospace;
            word-break: break-all;
            white-space: pre-wrap;
            min-height: 2.5rem;
            display: flex;
            align-items: center;
        }
        .output-probabilities {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        .output-probabilities > div {
            background-color: #1a202c;
            padding: 0.75rem;
            border-radius: 0.375rem;
            color: #a0aec0;
            font-family: 'Courier New', Courier, monospace;
            word-break: break-all;
            white-space: pre-wrap;
            min-height: 2.5rem;
            display: flex;
            align-items: center;
        }

        .error-message {
            color: #fc8181; /* Red for errors */
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }
        h1 {
            color: #63b3ed;
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.5rem;
        }
        .info-text {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 1rem;
            line-height: 1.5;
        }
        .info-text strong {
            color: #cbd5e0;
        }
        .circuit-diagram {
            background-color: #1a202c;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            line-height: 1.8;
            white-space: pre;
            overflow-x: auto;
            color: #a0aec0;
        }
        select {
            background-color: #4a5568;
            border: 1px solid #6b7280;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            color: #e2e8f0;
            width: 100%;
            box-sizing: border-box;
        }
        select:focus {
            outline: none;
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5);
        }
        #probabilityVisualizationCanvas {
            width: 100%; /* Stretches to full width of its parent panel */
            height: 550px; /* Increased height for better visualization */
            background-color: #000;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            touch-action: none; /* Disable default touch actions for custom controls */
            margin-top: 1rem;
        }

        /* New styles for the full-width visualization container */
        .full-width-viz-container {
            max-width: 100%; /* Allows this container to span the full viewport width */
            width: 100%;
            padding: 1.5rem; /* Maintain padding */
            margin-top: 1.5rem; /* Add some space from panels above */
            box-sizing: border-box;
        }

        .full-width-viz-panel {
            width: 100%; /* Make the panel itself take full width of its container */
            max-width: 1200px; /* Limit the content width inside the panel for readability */
            margin: 0 auto; /* Center the panel */
            background-color: #2d3748;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2 class="text-xl font-bold text-center mb-4">Initial Three-Qubit State</h2>
            <div class="info-text mb-4">
                <p>Select a pre-defined initial state for your three-qubit system. This system has $2^3 = 8$ basis states:</p>
                <p>$|000\rangle, |001\rangle, |010\rangle, |011\rangle, |100\rangle, |101\rangle, |110\rangle, |111\rangle$</p>
                <p>The sum of the squares of the magnitudes of all amplitudes must be 1.</p>
            </div>
            <div class="input-group">
                <label for="initialStateSelect">Select Initial State:</label>
                <select id="initialStateSelect">
                    <option value="000">|000⟩ (Classical Zero)</option>
                    <option value="plusplusplus">|+++⟩ (Superposition)</option>
                    <option value="ghz">GHZ State (Entangled)</option>
                    <option value="w">W State (Entangled)</option>
                </select>
            </div>
            <button id="setInitialStateBtn">Set Initial State</button>
            <div class="error-message" id="initialStateError"></div>
        </div>

        <div class="panel">
            <h2 class="text-xl font-bold text-center mb-4">Apply Toffoli (CCNOT) Gate</h2>
            <div class="info-text mb-4">
                <p>The **Toffoli (CCNOT) gate** is a three-qubit gate. It flips the **target qubit** only if **both control qubits are $|1\rangle$**.</p>
                <p>This gate is universal for classical computation and crucial for quantum algorithms.</p>
            </div>
            <div class="input-group">
                <label for="controlQubit1">Control Qubit 1:</label>
                <select id="controlQubit1">
                    <option value="0">Qubit 1</option>
                    <option value="1">Qubit 2</option>
                    <option value="2">Qubit 3</option>
                </select>
            </div>
            <div class="input-group">
                <label for="controlQubit2">Control Qubit 2:</label>
                <select id="controlQubit2">
                    <option value="1">Qubit 2</option>
                    <option value="0">Qubit 1</option>
                    <option value="2">Qubit 3</option>
                </select>
            </div>
            <div class="input-group">
                <label for="targetQubit">Target Qubit:</label>
                <select id="targetQubit">
                    <option value="2">Qubit 3</option>
                    <option value="0">Qubit 1</option>
                    <option value="1">Qubit 2</option>
                </select>
            </div>
            <button id="applyToffoliBtn">Apply Toffoli Gate</button>
            <div class="error-message" id="toffoliError"></div>

            <h3 class="text-lg font-bold mt-6 mb-2">Quantum Circuit Diagram</h3>
            <div class="circuit-diagram" id="circuitDiagram">
                Qubit 1: |0> ---
                Qubit 2: |0> ---
                Qubit 3: |0> ---
            </div>
        </div>

        <div class="panel">
            <h2 class="text-xl font-bold text-center mb-4">Resulting Three-Qubit State</h2>
            <h3 class="text-lg font-bold mb-2">Complex Amplitudes:</h3>
            <div class="output-complex" id="amplitudeOutput">
                <!-- Amplitudes will be dynamically added here -->
            </div>

            <h3 class="text-lg font-bold mt-6 mb-2">Measurement Probabilities:</h3>
            <div class="output-probabilities" id="probabilityOutput">
                <!-- Probabilities will be dynamically added here -->
            </div>
            <div class="info-text mt-4">
                <p>The **complex amplitudes** show the full quantum state, including phase information crucial for entanglement.</p>
                <p>The **measurement probabilities** tell you the likelihood of observing each classical outcome when you measure the qubits.</p>
            </div>
        </div>
    </div>

    <!-- New container for the full-width 3D visualization -->
    <div class="full-width-viz-container">
        <div class="full-width-viz-panel">
            <h3 class="text-xl font-bold text-center mb-4">3D Probability Visualization:</h3>
            <div class="info-text mb-4">
                <p>This interactive 3D bar chart visualizes the quantum state of your three qubits. It helps you understand how the probabilities and phases of different measurement outcomes change as you apply quantum gates.</p>
                <ul>
                    <li>The **height of each bar** shows the **probability** of measuring that specific three-qubit state (e.g., $|000\rangle, |001\rangle, \dots, |111\rangle$). A taller bar means a higher chance of that outcome.</li>
                    <li>The **color of each bar** represents the **phase** of the complex amplitude for that state. Phases are crucial for quantum phenomena like interference and entanglement.</li>
                    <li>**Interact:** Click and drag to **rotate** the visualization. Use your mouse scroll wheel to **zoom** in and out.</li>
                </ul>
            </div>
            <canvas id="probabilityVisualizationCanvas"></canvas>
        </div>
    </div>

    <script>
        // Complex number class (reused from previous app)
        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            magnitude() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }

            magnitudeSq() {
                return this.re * this.re + this.im * this.im;
            }

            multiply(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }

            // For multiplying by a scalar
            scale(scalar) {
                return new Complex(this.re * scalar, this.im * scalar);
            }

            toString() {
                if (this.im === 0) return this.re.toFixed(4);
                if (this.re === 0) return this.im.toFixed(4) + 'i';
                return `${this.re.toFixed(4)} ${this.im >= 0 ? '+' : '-'} ${Math.abs(this.im).toFixed(4)}i`;
            }

            arg() {
                // Handle the case where magnitude is zero to avoid NaN
                if (this.magnitude() === 0) {
                    return 0; // Phase of a zero vector is undefined, but 0 is a reasonable default
                }
                return Math.atan2(this.im, this.re);
            }
        }

        // Global state vector for three qubits (8 complex amplitudes)
        let threeQubitState = Array(8).fill(new Complex(0, 0)); // Initialize with zeros

        // Pre-defined 3-qubit states
        const SQRT2_INV = 1 / Math.sqrt(2);
        const SQRT3_INV = 1 / Math.sqrt(3);
        const SQRT8_INV = 1 / Math.sqrt(8);

        const PRESET_STATES = {
            "000": [new Complex(1, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0),
                    new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)],
            "plusplusplus": [new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0),
                             new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0), new Complex(SQRT8_INV, 0)],
            "ghz": [new Complex(SQRT2_INV, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0),
                    new Complex(0, 0), new Complex(0, 0), new Complex(0, 0), new Complex(SQRT2_INV, 0)],
            "w": [new Complex(0, 0), new Complex(SQRT3_INV, 0), new Complex(SQRT3_INV, 0), new Complex(0, 0),
                  new Complex(SQRT3_INV, 0), new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)]
        };

        // Three.js Global Variables for Probability Visualization
        let probScene, probCamera, probRenderer;
        let barMeshes = []; // Array to hold the 3D bar meshes
        let probLabels = []; // Array to hold the text labels for the bars
        let probIsDragging = false;
        let probPreviousMousePosition = { x: 0, y: 0 };
        let probRotation = { x: 0, y: 0 }; // Store current rotation for the bar chart group

        const BASIS_STATES_3Q = ["|000⟩", "|001⟩", "|010⟩", "|011⟩", "|100⟩", "|101⟩", "|110⟩", "|111⟩"];

        // Function to map phase angle (radians) to HSL color
        function phaseToHslColor(phase) {
            let hue = (phase + Math.PI) / (2 * Math.PI);
            if (hue < 0) hue += 1;
            if (hue > 1) hue -= 1;
            const saturation = 0.8;
            const lightness = 0.6;
            return new THREE.Color().setHSL(hue, saturation, lightness);
        }

        // Add text labels for bars
        function addTextLabel(parentObject, text, position, color) {
            const loader = new THREE.FontLoader();
            loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(text, {
                    font: font,
                    size: 0.2,
                    height: 0.01,
                });
                const textMaterial = new THREE.MeshBasicMaterial({ color: color });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.copy(position);
                textMesh.geometry.computeBoundingBox();
                textMesh.position.x -= (textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x) / 2;
                parentObject.add(textMesh);
                probLabels.push(textMesh);
            });
        }

        // Function to update the 3D probability visualization
        function updateProbabilityVisualization(normalizedState) {
            console.log("Updating probability visualization...");
            const maxHeight = 4; // Max height for a bar (e.g., for 100% probability), increased for larger canvas
            const baseHeight = 0.01; // Minimum height to always show the bar

            for (let i = 0; i < 8; i++) {
                const probability = normalizedState[i].magnitudeSq();
                const phase = normalizedState[i].arg();

                const bar = barMeshes[i];
                const newHeight = Math.max(baseHeight, probability * maxHeight); // Ensure a minimum height

                // Update bar height
                bar.scale.y = newHeight / bar.geometry.parameters.height;
                bar.position.y = (newHeight / 2) - (bar.geometry.parameters.height / 2); // Adjust position to keep base at y=0

                // Update bar color based on phase
                bar.material.color.copy(phaseToHslColor(phase));

                // Update label position (if needed, relative to bar)
                if (probLabels[i]) {
                    probLabels[i].position.y = newHeight / 2 + 0.3; // Position label slightly above the bar
                }
            }
            renderProbViz();
        }

        // Initialize Three.js scene for the probability visualization
        function initProbabilityVisualization() {
            const canvas = document.getElementById('probabilityVisualizationCanvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            probScene = new THREE.Scene();
            probCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
            probRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            probRenderer.setSize(width, height);
            probRenderer.setClearColor(0x000000, 0);

            // Group to hold all bars and labels for easier rotation
            const barGroup = new THREE.Group();
            probScene.add(barGroup);

            const barWidth = 0.6; // Smaller width for 8 bars
            const barDepth = 0.6;
            const spacing = 0.1; // Smaller spacing
            const totalWidth = barWidth * 8 + spacing * 7;
            const startX = -totalWidth / 2 + barWidth / 2; // Center the bars

            for (let i = 0; i < 8; i++) { // 8 bars for 3 qubits
                const geometry = new THREE.BoxGeometry(barWidth, 0.1, barDepth);
                const material = new THREE.MeshBasicMaterial({ color: 0x4299e1 });
                const bar = new THREE.Mesh(geometry, material);
                bar.position.set(startX + i * (barWidth + spacing), 0, 0);
                barGroup.add(bar);
                barMeshes.push(bar);

                // Add text label for each bar
                addTextLabel(barGroup, BASIS_STATES_3Q[i], new THREE.Vector3(startX + i * (barWidth + spacing), -0.7, 0), 0xe2e8f0);
            }

            probCamera.position.set(0, 3, 8); // Adjusted camera position for 8 bars
            probCamera.lookAt(barGroup.position);

            const ambientLight = new THREE.AmbientLight(0x404040);
            probScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            probScene.add(directionalLight);

            canvas.addEventListener('mousedown', onProbPointerDown);
            canvas.addEventListener('mousemove', onProbPointerMove);
            canvas.addEventListener('mouseup', onProbPointerUp);
            canvas.addEventListener('mouseleave', onProbPointerUp);

            canvas.addEventListener('touchstart', onProbPointerDown, { passive: false });
            canvas.addEventListener('touchmove', onProbPointerMove, { passive: false });
            canvas.addEventListener('touchend', onProbPointerUp);

            canvas.addEventListener('wheel', onProbMouseWheel);

            window.addEventListener('resize', onProbWindowResize);

            animateProbViz();
        }


        function onProbWindowResize() {
            const canvas = document.getElementById('probabilityVisualizationCanvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            probCamera.aspect = width / height;
            probCamera.updateProjectionMatrix();
            probRenderer.setSize(width, height);
            renderProbViz();
        }

        function onProbPointerDown(event) {
            probIsDragging = true;
            probPreviousMousePosition.x = event.touches ? event.touches[0].clientX : event.clientX;
            probPreviousMousePosition.y = event.touches ? event.touches[0].clientY : event.clientY;
            event.preventDefault();
        }

        function onProbPointerMove(event) {
            if (!probIsDragging) return;

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const deltaX = clientX - probPreviousMousePosition.x;
            const deltaY = clientY - probPreviousMousePosition.y;

            const rotationSpeed = 0.01;
            probRotation.y += deltaX * rotationSpeed;
            probRotation.x += deltaY * rotationSpeed;

            probRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, probRotation.x));

            probScene.children[0].rotation.x = probRotation.x;
            probScene.children[0].rotation.y = probRotation.y;

            probPreviousMousePosition.x = clientX;
            probPreviousMousePosition.y = clientY;

            renderProbViz();
            event.preventDefault();
        }

        function onProbPointerUp() {
            probIsDragging = false;
        }

        function onProbMouseWheel(event) {
            event.preventDefault();

            const zoomSpeed = 0.1;
            probCamera.position.z += event.deltaY * zoomSpeed * 0.01;

            probCamera.position.z = Math.max(2, Math.min(15, probCamera.position.z)); // Adjusted zoom range for 8 bars

            renderProbViz();
        }

        function animateProbViz() {
            requestAnimationFrame(animateProbViz);
            renderProbViz();
        }

        function renderProbViz() {
            probRenderer.render(probScene, probCamera);
        }


        // Function to update the displayed state and probabilities
        function updateDisplay() {
            const totalMagnitudeSq = threeQubitState.reduce((sum, c) => sum + c.magnitudeSq(), 0);
            let normalizedState = threeQubitState.map(c => c.scale(1 / Math.sqrt(totalMagnitudeSq)));

            const amplitudeOutputDiv = document.getElementById('amplitudeOutput');
            amplitudeOutputDiv.innerHTML = ''; // Clear previous content
            normalizedState.forEach((amp, index) => {
                const div = document.createElement('div');
                div.innerHTML = `α<sub>${BASIS_STATES_3Q[index].replace(/\||⟩/g, '')}</sub>: ${amp.toString()}`;
                amplitudeOutputDiv.appendChild(div);
            });

            const probabilityOutputDiv = document.getElementById('probabilityOutput');
            probabilityOutputDiv.innerHTML = ''; // Clear previous content
            normalizedState.forEach((amp, index) => {
                const div = document.createElement('div');
                div.innerHTML = `P(${BASIS_STATES_3Q[index]}): ${(amp.magnitudeSq() * 100).toFixed(2)}%`;
                probabilityOutputDiv.appendChild(div);
            });

            // Update 3D probability visualization
            updateProbabilityVisualization(normalizedState);
        }

        // Function to normalize the state vector (ensures sum of probabilities is 1)
        function normalizeStateVector(stateVector) {
            const sumOfSquares = stateVector.reduce((sum, c) => sum + c.magnitudeSq(), 0);
            if (sumOfSquares === 0) {
                return stateVector.map(() => new Complex(0, 0));
            }
            const normFactor = Math.sqrt(sumOfSquares);
            return stateVector.map(c => c.scale(1 / normFactor));
        }

        // Function to apply an 8x8 matrix to an 8-element complex vector
        function applyMatrix(matrix, stateVector) {
            let newState = Array(8).fill(null).map(() => new Complex(0, 0));
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    // Ensure matrix[i][j] is a Complex object before calling multiply
                    newState[i] = newState[i].add(matrix[i][j].multiply(stateVector[j]));
                }
            }
            return newState;
        }

        // Add method to Complex class for addition
        Complex.prototype.add = function(other) {
            return new Complex(this.re + other.re, this.im + other.im);
        };

        // Identity matrix for 8x8
        const IDENTITY_8x8 = Array(8).fill(null).map((_, i) =>
            Array(8).fill(null).map((_, j) => new Complex(i === j ? 1 : 0, 0))
        );

        // Function to create a Toffoli matrix given control and target qubits
        // Qubits are 0-indexed (Q1=0, Q2=1, Q3=2)
        function createToffoliMatrix(control1, control2, target) {
            // Create a deep copy of the IDENTITY_8x8 matrix, ensuring Complex objects are preserved
            let matrix = IDENTITY_8x8.map(row => row.map(complex => new Complex(complex.re, complex.im)));

            // Find the indices where both control qubits are 1
            // Example: if Q1=0, Q2=1 are controls, target Q3=2
            // We need to flip states where bits at control1 and control2 positions are 1
            // e.g., for |110> and |111>
            // For a 3-qubit state |q2 q1 q0>, the indices are:
            // |000> = 0, |001> = 1, |010> = 2, |011> = 3,
            // |100> = 4, |101> = 5, |110> = 6, |111> = 7

            // Iterate through all 8 basis states
            for (let i = 0; i < 8; i++) {
                // Convert index 'i' to its 3-bit binary representation
                // Ensure it's padded to 3 bits: e.g., 0 -> "000", 1 -> "001", etc.
                const binaryState = i.toString(2).padStart(3, '0');

                // Check if both control qubits are '1'
                // Note: Qubit 1 is at index 0, Qubit 2 at index 1, Qubit 3 at index 2
                // In binaryState string, index 0 is Q3, index 1 is Q2, index 2 is Q1
                // So, map control1, control2, target (0,1,2) to (2,1,0) for binaryState string access
                const isControl1Set = binaryState[2 - control1] === '1';
                const isControl2Set = binaryState[2 - control2] === '1';

                if (isControl1Set && isControl2Set) {
                    // If both controls are 1, the target qubit flips
                    // Calculate the index of the flipped state
                    let flippedBinaryStateArray = binaryState.split('');
                    flippedBinaryStateArray[2 - target] = flippedBinaryStateArray[2 - target] === '0' ? '1' : '0';
                    const flippedIndex = parseInt(flippedBinaryStateArray.join(''), 2);

                    // Swap the rows in the matrix
                    matrix[i][i] = new Complex(0, 0); // Original diagonal element becomes 0
                    matrix[i][flippedIndex] = new Complex(1, 0); // New connection

                    // Also handle the reverse swap for the flipped state to maintain unitarity
                    // This ensures that if we apply the gate to the flipped state, it goes back
                    matrix[flippedIndex][flippedIndex] = new Complex(0, 0);
                    matrix[flippedIndex][i] = new Complex(1, 0);
                }
            }
            return matrix;
        }

        // Function to update the circuit diagram for 3 qubits
        function updateCircuitDiagram(control1, control2, target, operation = 'initial') {
            const diagramDiv = document.getElementById('circuitDiagram');
            let diagramLines = Array(3).fill('   ---'); // 3 qubits
            const qubitLabels = ['Qubit 1', 'Qubit 2', 'Qubit 3'];

            if (operation === 'initial') {
                diagramLines = qubitLabels.map(label => `${label}: |0> ---`);
            } else if (operation === 'Toffoli') {
                // Initialize lines
                diagramLines[0] = `${qubitLabels[0]}: |0> ---`;
                diagramLines[1] = `${qubitLabels[1]}: |0> ---`;
                diagramLines[2] = `${qubitLabels[2]}: |0> ---`;

                // Add control dots
                diagramLines[control1] += '●';
                diagramLines[control2] += '●';

                // Add target X
                diagramLines[target] += 'X';

                // Connect controls and target with vertical lines
                const minQ = Math.min(control1, control2, target);
                const maxQ = Math.max(control1, control2, target);

                for (let i = minQ; i <= maxQ; i++) {
                    if (i !== control1 && i !== control2 && i !== target) {
                        diagramLines[i] += '|';
                    }
                }

                // Pad lines to align
                const maxLength = Math.max(...diagramLines.map(line => line.length));
                diagramLines = diagramLines.map(line => line.padEnd(maxLength, '-'));
            }
            diagramDiv.textContent = diagramLines.join('\n');
        }

        // --- Event Listeners ---

        document.getElementById('setInitialStateBtn').addEventListener('click', () => {
            const selectedState = document.getElementById('initialStateSelect').value;
            if (PRESET_STATES[selectedState]) {
                threeQubitState = PRESET_STATES[selectedState].map(c => new Complex(c.re, c.im)); // Deep copy
                updateDisplay();
                updateCircuitDiagram(0, 1, 2, 'initial'); // Reset diagram to initial state
            } else {
                document.getElementById('initialStateError').textContent = 'Invalid state selected.';
            }
        });

        document.getElementById('applyToffoliBtn').addEventListener('click', () => {
            const control1 = parseInt(document.getElementById('controlQubit1').value);
            const control2 = parseInt(document.getElementById('controlQubit2').value);
            const target = parseInt(document.getElementById('targetQubit').value);

            const toffoliErrorDiv = document.getElementById('toffoliError');
            toffoliErrorDiv.textContent = '';

            if (control1 === target || control2 === target || control1 === control2) {
                toffoliErrorDiv.textContent = 'Control qubits must be distinct from each other and from the Target qubit.';
                return;
            }

            const toffoliMatrix = createToffoliMatrix(control1, control2, target);
            threeQubitState = applyMatrix(toffoliMatrix, threeQubitState);
            threeQubitState = normalizeStateVector(threeQubitState);
            updateDisplay();
            updateCircuitDiagram(control1, control2, target, 'Toffoli');
        });

        // Initialize display and 3D visualization on page load
        window.onload = function() {
            initProbabilityVisualization(); // Initialize the 3D bars
            // Set initial state to the default selected in the dropdown
            threeQubitState = PRESET_STATES[document.getElementById('initialStateSelect').value].map(c => new Complex(c.re, c.im));
            updateDisplay(); // Update all displays with initial state
            updateCircuitDiagram(0, 1, 2, 'initial'); // Initial diagram
        };
    </script>
</body>
</html>
